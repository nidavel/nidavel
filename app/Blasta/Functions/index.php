<?php
 require_once base_path('/app/Blasta/Classes/Body.php');  /**  * Runs just after the opening body tag  */ function startBody() {   return Body::getPrepends(); }  /**  * Runs just before the closing body tag  */ function endBody() {   return Body::getAppends(); }  /**  * Appends to body  */ function appendToBody(string $entity) {   Body::append($entity); }  /**  * Prepends to body  */ function prependToBody(string $entity) {   Body::prepend($entity); }  require_once base_path('app/Blasta/Functions/settings.php');  /**  * Sets the theme color  */ function setThemeColor(string $color) {  settings('w', 'general.theme_color', $color); }  /**  * This function is used to add customizable selectors  * for custom editing  */ function customizeSelectors(string|null $name = null, array|string|null $selectors = null) {  static $allSelectors;   if ($name === null && $selectors == null) {   return $allSelectors;  }   $allowedProperties = [   'color',   'background-color',   'border-color'  ];   $tempSelectors = [];  foreach ($selectors as $selector => $properties) {   if (empty($selector[0])) {    $tempSelectors[$properties] = $allowedProperties;    continue;   } else {    $tempProperties = [];    if (is_array($properties)) {     foreach ($properties as $property) {      if (!in_array($property, $allowedProperties)) {       continue;      }      $tempProperties[] = $property;     }    }    else if (is_string($properties)) {     if (!in_array($properties, $allowedProperties)) {      continue;     }     $tempProperties[] = $properties;    }     $tempSelectors[$selector] = $tempProperties;   }  }   $allSelectors[$name] = $tempSelectors;   return $allSelectors; }  /**  * This function gets all the customizable selectors  */ function getCustomizeableSelectors() {  return customizeSelectors(); }  /**  * This function returns the names of all customized styles  */ function getCustomizedStyleNames() {  $customizedStyles = settings('r', 'general.customized_style_names');  $customizedStyles = explode("'", $customizedStyles);  array_shift($customizedStyles);   return $customizedStyles; }  /**  * Adds a style name to the list of customized styles  */ function addCustomizedStyleName(string $name) {  $customizedStyles = settings('r', 'general.customized_style_names');   if (!isStyleCustomized($name)) {   settings('a', 'general.customized_style_names', "'$name");  }   return true; }  /**  * Removes a style name from the list of customized styles  */ function removeCustomizedStyleName(string $name) {  $customizedStyles = settings('r', 'general.customized_style_names');   if (empty($customizedStyles)) {   return;  }   $customizedStyles = str_replace("'$name", '', $customizedStyles);     settings('w', 'general.customized_style_names', $customizedStyles);   return true; }  /**  * This function checks if a given style name   * is added to the customized list  */ function isStyleCustomized(string $name) {  $customizedStyles = settings('r', 'general.customized_style_names');   if (strpos($customizedStyles, $name) > 0) {   return true;;  }   return false; }  /**  * This function checks if a particular selector is active  * in an active customized style  */ function isSelectorCustomized(string $input) {  $value = explode("'", $input);  $name = $value[0];  $selector = $value[1];   if (isStyleCustomized($name) === false) {   return false;  }   $styleFile = base_path("app/CustomizedStyles/$name");  $style = file_get_contents(base_path("app/CustomizedStyles/$name"));   if (strpos($style, $selector)) {   return true;  }   return false; }  /**  * This function checks if a particular property is active  * in an active selector in an active customized style  */ function isPropertyCustomized(string $input) {  $value = explode("'", $input);  $name = $value[0];  $selector = $value[1];  $property = $value[2];  $falsePositives = [   'color'  ];   if (isStyleCustomized($name) === false) {   return false;  }   $styleFile = base_path("app/CustomizedStyles/$name");  $style = file_get_contents($styleFile);   if (strpos($style, $selector)) {   $fp = fopen($styleFile, 'r');   foreach (readFileLine($fp) as $line) {    $idx = strpos($line, $selector);    if ($idx < 1) {     continue;    } else {     $content = '';      if (in_array($property, $falsePositives)) {      $content = substr($line, strpos($line, $property) - 1, strlen($property) + 1);      if ($content[0] === '-') {       $content = substr($line, strpos($line, $property) - 1);       while ($content[0] === '-' && strlen($content) > 0) {        $content = substr($line, strpos($content, $property) - 1);        if ($content[0] !== '-') {         $content = substr($line, strpos($content, $property) - 1, strlen($property) + 1);         break;        }       }      }      $content = ltrim($content, $content[0]);     } else {      $content = substr($line, strpos($line, $property), strlen($property));     }      if ($content === $property) {      fclose($fp);      return true;     }    }   }    fclose($fp);  }   return false; }  /**  * This function gets the value of a given property in a customized style  */ function getCustomizedPropertyValue(string $input) {  $value = null;  $input = explode("'", $input);  $styleFile = base_path('app/CustomizedStyles/'.$input[0]);  $selector = $input[1];  $property = $input[2];   if (!file_exists($styleFile)) {   return null;  }   $matchx = null;  $content = null;  $fp = fopen($styleFile, 'r');  foreach (readFileLine($fp) as $line) {   $matchx = getPropertyAndValue($line, $selector, $property);   if (is_null($matchx)) {    continue;   } else {    break;   }  }   fclose($fp);  if (!empty($matchx)) {   $value = ltrim($matchx, "$property:");   $value = rtrim($value, ';');  }   return "$value"; }  /**  * This function returns the specified property and value of a given selector  */ function getPropertyAndValue(string $line, string $selector, string $property) {  $propIdx = null;  $content = null;  $matchx = '';   $idx = strpos($line, $selector);  $falsePositives = [   'color'  ];   if ($idx < 1) {   return null;  } else {   if (in_array($property, $falsePositives)) {    $content = substr($line, strpos($line, $property) - 1);     while ($content[0] === '-' && strlen($content) > 0) {     $content = substr($line, strpos($content, $property) - 1);     if ($content[0] !== '-') {      $content = substr($line, strpos($content, $property) - 1, strlen($property) + 1);      break;     }    }        $content = ltrim($content, $content[0]);    $propIdx = strpos($line, $content);   } else {    $propIdx = strpos($line, $property);    $content = substr($line, $propIdx);   }      $matchx = substr($content, 0, strpos($content, ';'));    return $matchx;  } }  /**  * This function extracts the red value in an rgba string  */ function getRedFromPropertyValue(string $input) {  $val = stripRGBText($input);  $val = explode(',', $val);  return  $val[0]; }  /**  * This function extracts the green value in an rgba string  */ function getGreenFromPropertyValue(string $input) {  $val = stripRGBText($input);  $val = explode(',', $val);  return  $val[1]; }  /**  * This function extracts the blue value in an rgba string  */ function getBlueFromPropertyValue(string $input) {  $val = stripRGBText($input);  $val = explode(',', $val);  return  $val[2]; }  /**  * This function extracts the alpha value in an rgba string  */ function getAlphaFromPropertyValue(string $input) {  $val = stripRGBText($input);  $val = explode(',', $val);   return  $val[3] ?? 1; }  /**  * This funtion takes a rgb or rgba string and returns the values within  * the parentheses  */ function stripRGBText(string $input) {  $val = trim($input);  $val = ltrim($val, 'rgba(');  $val = ltrim($val, 'rgb(');  $val = rtrim($val, ')');   return $val; }  /**  * This function converts a rgb string to a rgba string  */ function parseRGBA($rgba) {  if (substr(trim($rgba), 0, 4) === 'rgba') {   return $rgba;  }   $rgba = str_replace('rgb', 'rgba', $rgba);  $rgba = str_replace('rgbaa', 'rgba', $rgba);  $rgba = str_replace(')', ', 1)', $rgba);   return $rgba; }  function readFileLine($fp) {  while (!feof($fp)) {   yield fgets($fp);  } }  /**  * A download function that gets a file from a url  * and saves it in a given location  */ function download(string $url, string $storageLocation): bool {  $filename = basename($url);       if (file_put_contents("$storageLocation/$filename", file_get_contents($url))) {    return true;  }    return false; }  /**  * Download a plugin from url  */ function downloadPlugin(string $url): bool {  return download($url, plugin_path()); }  /**  * Download a theme from url  */ function downloadTheme(string $url): bool {  return download($url, theme_path()); }   /**  * An extract function to extract zipped file to a given location  */ function extractFile(string $zipped, string $location): bool {  $zip = new ZipArchive;  $filename = basename($zipped);   $res = $zip->open($zipped);   if ($res === true) {   $zip->extractTo("$location");   $zip->close();   return true;  } else {   return false;  } }  /**  * Extract downloaded plugin  */ function extractPlugin(string $zipped): bool {  return extractFile($zipped, plugin_path()); }  /**  * Extract downloaded theme  */ function extractTheme(string $zipped): bool {  return extractFile($zipped, theme_path()); }  /**  * Deletes zipped file  */ function deleteZipped(string $filename): bool {  $finfo = finfo_open(FILEINFO_MIME_TYPE);  $mimeType = finfo_file($finfo, $filename);  finfo_close($finfo);   if ($mimeType === 'application/zip' || $mimeType === 'application/x-rar-compressed') {   return unlink($filename);  }   return false; }  /**  * Deletes zipped plugin  */ function deleteZippedPlugin(string $filename): bool {  return deleteZipped(plugin_path("/$filename")); }  /**  * Deletes zipped theme  */ function deleteZippedTheme(string $filename): bool {  return deleteZipped(theme_path("/$filename")); }  function exportAssets() {  if (file_exists(front_path('/assets.json'))) {   $assets = file_get_contents(front_path('/assets.json'));   $assets = json_decode($assets)->assets;  } else {   return;  }   if (file_exists(public_path('/my_exports/assets'))) {   rrmdir(public_path('/my_exports/assets'));  }   foreach ($assets as $asset) {   $dirs = explode('/', $asset);   $numDirs = count($dirs);   if ($numDirs > 1) {    array_pop($dirs);    $dirs = implode('/', $dirs);     if (!is_dir(public_path("/my_exports/$dirs"))) {     mkdir(public_path("/my_exports/$dirs"), 0777, true);    }   }   copy(front_path("/$asset"), public_path("/my_exports/$asset"));  } }  function exportLink($url = '/', $level = -1) {  $link = homeUrl($url, $level);   if ($_SERVER['SERVER_PORT'] == 8001   && substr($url, 0, 4) != 'http') {   $link .= '.html';  }   return $link; }  function fetch(string $url, string $method = 'GET', $payload = [], array $options = []) {  $ch = curl_init($url);   if (!empty($payload)) {   $payload = json_encode($payload);   curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);  }   if (!empty($options)) {   curl_setopt_array($ch, $options);  }    curl_setopt($ch, CURLOPT_HTTPHEADER, [   'Content-Type: application/json'  ]);  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);   $result = curl_exec($ch);  curl_close($ch);   return $result; }  /**  * Returns a list of directory contents in a directory  */ function getContents(string $dir) {  $contents = [];  $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   if (!$fileinfo->isDot()) {    $contents[] = $fileinfo->getFileName();   }  }   return $contents; }  /**  * Returns a list of directory contents in a directory  * except given  */ function getContentsExcept(string $dir, ?string $except = null) {  $contents = [];  $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   $filename = $fileinfo->getFilename();   if (!$fileinfo->isDot() && $filename !== $except) {    $contents[] = $filename;   }  }   return $contents; }  /**  * Returns a list of directory names in a directory  */ function getDirectories(string $dir) {  $dirs = [];  $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   if (!$fileinfo->isDot() && $fileinfo->isDir()) {    $dirs[] = $fileinfo->getFileName();   }  }   return $dirs; }  /**  * Returns a list of file names in a directory  */ function getFiles(string $dir) {  $files = [];  if (!file_exists($dir)) {   return $files;  }    $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   if (!$fileinfo->isDot() && $fileinfo->isFile()) {    $files[] = $fileinfo->getFileName();   }  }   return $files; }  /**  * Deletes a directory  */ function deleteDir(string $path, bool $recursive = false) {  if ($recursive === false) {   return rmdir($path);  }   return rrmdir($path); }  /**  * Recursively deletes a directory  */ function rrmdir($path) {  if (!file_exists($path)) {   return;  }    $it = new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS);  $files = new RecursiveIteratorIterator($it,      RecursiveIteratorIterator::CHILD_FIRST);  foreach($files as $file) {   if ($file->isDir()){    rmdir($file->getPathname());   } else {    unlink($file->getPathname());   }  }  rmdir($path); }  /**  * Recursively copies the contents of a directory  */ function rCopy(  string $sourceDirectory,  string $destinationDirectory,  string $childFolder = '' ): void {  $directory = opendir($sourceDirectory);   if (is_dir($destinationDirectory) === false) {   mkdir($destinationDirectory);  }   if ($childFolder !== '') {   if (is_dir("$destinationDirectory/$childFolder") === false) {    mkdir("$destinationDirectory/$childFolder");   }    while (($file = readdir($directory)) !== false) {    if ($file === '.' || $file === '..') {     continue;    }     if (is_dir("$sourceDirectory/$file") === true) {     rCopy("$sourceDirectory/$file", "$destinationDirectory/$childFolder/$file");    } else {     copy("$sourceDirectory/$file", "$destinationDirectory/$childFolder/$file");    }   }    closedir($directory);    return;  }   while (($file = readdir($directory)) !== false) {   if ($file === '.' || $file === '..') {    continue;   }    if (is_dir("$sourceDirectory/$file") === true) {    rCopy("$sourceDirectory/$file", "$destinationDirectory/$file");   }   else {    copy("$sourceDirectory/$file", "$destinationDirectory/$file");   }  }   closedir($directory); }  require_once base_path('/app/Blasta/Classes/Head.php');  /**  * The meta tags in the post head  */ function postHead($post = null) {  $protocol = settings('r', 'general.protocol');  $domain = settings('r', 'general.domain');   $postHeadString = '';  $postHeadMeta = Head::get();   if ($post !== null) {   $postHeads[] = '<meta name="author" content="'.$post->author.'" />';   $postHeads[] = '<meta name="description" content="'.$post->description.'" />';   $postHeads[] = '<meta name="keywords" content="'.$post->keywords.'" />';   $postHeads[] = '<meta name="theme-color" content="'.settings('r', 'general.theme_color').'" />';   $postHeads[] = '<title>'.$post->title.'</title>';    $postHeads[] = '<meta property="og:title" content="'.$post->title.'" />';   $postHeads[] = '<meta property="og:url" content="'.$protocol.'://'.$domain.'/'.$post->post_type.'s/'.$post->link.'.html" />';   $postHeads[] = '<meta property="og:image" content="'.$protocol.'://'.$domain.'/uploads/'.$post->featured_image.'" />';   $postHeads[] = '<meta property="og:image:width" content="1200" />';   $postHeads[] = '<meta property="og:image:height" content="630" />';   $postHeads[] = '<meta property="og:type" content="article" />';   $postHeads[] = '<meta property="og:description" content="'.$post->description.'" />';    foreach ($postHeads as $postHead) {    $postHeadString .= "$postHead\n";   }  }   $postHeadString .= $postHeadMeta;    return $postHeadString; }  /**  * The customized style to the head   */ function customizedStyles() {  $style = '';  $styleNames = getCustomizedStyleNames();   if (!empty($styleNames)) {   $style .= "<style>\n";  } else {   return null;  }   foreach ($styleNames as $styleName) {   $style .= file_get_contents(base_path("app/CustomizedStyles/$styleName"));  }   $style .= "\n</style>";   return $style; }  /**  * Adds customized style to the document  */ function addCustomizedStyles() {  return customizedStyles(); }  /**  * Appends to post head  */ function appendToHead(string $node) {  Head::append($node); }  function homeUrl(string $url = '/', $level = -1) : string {  if ($level == -1) {   $level = count(explode('/', $url)) - 1;  }   $url = trim($url, '.');  $url = trim($url, '/');   if ($_SERVER['SERVER_PORT'] == 8001) {   if ($level == 0) {    $url = './' . $url;   }   while ($level > 0) {    $url = '../' . $url;    $level--;   }  } else {   $url = '/' . $url;  }   return $url; }  require_once base_path('/app/Blasta/Classes/Settings.php');  function addMenu(string $title, string $url, ?string $target = null) {  $settings = Settings::getInstance();  $settings->add('menu', [   $title => [    'url'    => $url,    'target' => $target   ]  ]); }  function getMenuList() {  $settings = Settings::getInstance();  return $settings->list('menu'); }  function removeMenu(string $title) {  $settings = Settings::getInstance();  $settings->remove('menu', $title); }  function clearMenu() {  $settings = Settings::getInstance();  $settings->clear('menu'); }  function getMenu() {  $newMenu = [];  $menu = getMenuList();   foreach ($menu as $title => $props) {   if (substr($props['url'], 0, 4) === 'http') {    $newMenu[] = $props['target'] == null     ? '<a href="'.$props['url'].'">'.ucfirst($title).'</a>'     : '<a href="'.$props['url'].'" target="'.$props['target'].'">'.ucfirst($title).'</a>';        continue;   }    $newMenu[] = $props['target'] == null    ? '<a href="'.exportLink($props['url']).'">'.ucfirst($title).'</a>'    : '<a href="'.exportLink($props['url']).'" target="'.$props['target'].'">'.ucfirst($title).'</a>';  }   return $newMenu; }  /**  * Creates a directory, and creates an index file in it  */ function mkUriDir(string $path): bool {  if (!is_dir($path)) {   if (!mkdir($path)) {    return false;   }  }   if (!file_exists("$path/index.html")) {   $fp = fopen("$path/index.html", 'w');   if (!fclose($fp)) {    return false;   }  }   return true; }  function dirPath(string $file = __FILE__) : string {  return dirname($file); }  function front_path(string $resource = '', bool $trailingSlash = false) : string {  $resource = '/' . ltrim($resource, '/');  $path = base_path() . '/resources/views/front' . $resource;  $path .= $trailingSlash === true ? '/' : '';  $path = str_replace('\\', '/', $path);  return $path; }  function plugin_path(string $resource = '', bool $trailingSlash = false): string {  $resource = '/' . ltrim($resource, '/');  $path = base_path() . '/app/Plugins' . $resource;  $path .= $trailingSlash === true ? '/' : '';  $path = str_replace('\\', '/', $path);  return $path; }  function theme_path(string $resource = '', bool $trailingSlash = false): string {  $resource = '/' . ltrim($resource, '/');  $path = base_path() . '/app/Themes' . $resource;  $path .= $trailingSlash === true ? '/' : '';  $path = str_replace('\\', '/', $path);  return $path; }  /**  * Returns the names of all installed plugins  */ function getPlugins() {  return getDirectories(plugin_path()); }  /**  * Returns the details of an installed plugin  */ function getPluginDetails(string $pluginName, bool $assoc = false) {  $details = file_get_contents(plugin_path("/$pluginName/details.json"));   return json_decode($details, $assoc); }  /**  * Checks if plugin exists  */ function pluginExists(string $pluginName): bool {  $plugin = plugin_path("/$pluginName");   if (file_exists($plugin)) {   return true;  }   return false; }  /**  * Marks a plugin as active  */ function markPluginActive(string $pluginName) {  if (!pluginExists($pluginName)) {   throw new Exception("Plugin $pluginName does not exist.");  }   $plugin = plugin_path("/$pluginName");  $mark = '';   $file = fopen("$plugin/ACTIVE", 'w');  fwrite($file, $mark);  fclose($file); }  /**  * Checks if a plugin is active  */ function isPluginActive(string $pluginName): bool {  if (!pluginExists($pluginName)) {   return false;  }   $plugin = plugin_path("/$pluginName");   if (file_exists("$plugin/ACTIVE")) {   return true;  }   return false; }  /**  * Unmarks a plugin as active  */ function unmarkPluginActive(string $pluginName) {  if (!isPluginActive($pluginName)) {   return;  }   $plugin = plugin_path("/$pluginName");   unlink("$plugin/ACTIVE"); }  /**  * Gets all active plugins  */ function getActivePlugins() {  $plugins = getPlugins();  $activePlugins = [];   foreach ($plugins as $plugin) {   if (isPluginActive($plugin)) {    $activePlugins[] = $plugin;   }  }   return $activePlugins; }  /**  * Gets all inactive plugins  */ function getInactivePlugins() {  $plugins = getPlugins();  $inactivePlugins = [];   foreach ($plugins as $plugin) {   if (!isPluginActive($plugin)) {    $inactivePlugins[] = $plugin;   }  }   return $inactivePlugins; }  /**  * Activates a plugin  */ function activatePlugin(string $pluginName) {  markPluginActive($pluginName);   loadActivePlugins(); }  /**  * Deactivates a plugin  */ function deactivatePlugin(string $pluginName) {  unmarkPluginActive($pluginName);   loadActivePlugins(); }  /**  * Loads all active plugins to memory  */ function loadActivePlugins() {  $activePlugins = getActivePlugins();   if (!empty($activePlugins)) {   foreach ($activePlugins as $activePlugin) {    require_once plugin_path("/$activePlugin/index.php");   }  } }  /**  * Loads all active plugins to memory  */ function deletePlugin(string $pluginName) {  if (isPluginActive($pluginName)) {   return false;  }   return deleteDir(plugin_path("/$pluginName"), true); }  /**  * Fetches available free plugins from repository  */ function fetchPlugins() {  $url  = 'https://localhost:5000/api/v0';  $content = file_get_contents($url); }  /* | This is a group of functions that should be used by third party devs | to trigger a function on any of the publish events */  function runOnPostPublish(string|array|callable $function = null) {  static $functions;   if (!is_null($function)) {   if (is_string($function)) {    $functions[] = $function;   }    if (is_array($function)) {    foreach ($function as $func) {     $functions[] = $func;    }   }  }   return $functions; }  function runFunctionsPostPublished() {  $functions = runOnPostPublish();    if (!empty($functions)) {   foreach ($functions as $function) {    if (is_string($function)) {     if (function_exists($function)) {      $function();     } else {      throw new Exception("Function $function does not exist", 1);     }    }   }  } }  /**  * Embeds script to the html  */ function embedScript(string $resource, string $location = 'head', array $attributes = []) {  $script = '<script';  foreach ($attributes as $attribute => $value) {   $script .= ' ' . $attribute . '="'. $value . '"';  }  $script .= ">\n";   $script .= file_get_contents($resource) . "\n";   $script .= '</script>';   switch ($location) {   case 'head':    appendToPostHead($script);    break;   case 'body':    appendToBody($script);    break;   default:    exit('Unknown location for embed script');  } }  /**  * Attaches script from online source to the html  */ function sourceScript(string $resource, string $location = 'body', array $attributes = []) {  $script = '<script src="' . $resource . '"';  foreach ($attributes as $attribute => $value) {   $script .= ' ' . $attribute . '="'. $value . '"';  }  $script .= "></script>\n";   switch ($location) {   case 'head':    appendToPostHead($script);    break;   case 'body':    appendToBody($script);    break;   default:    exit('Unknown location for embed script');  } } function toSnakeCase(string $delimiter, string $str): string {  return str_replace($delimiter, '_', $str); }  function unSnakeCase(string $delimiter, string $str): string {  return str_replace('_', $delimiter, $str); }  function spaceToDash(string $str, bool $trimSpaces = true) : string {  if ($trimSpaces === true) {   $str = trim($str);  }   $str = str_replace(' ', '-', $str);   return $str; }  function dashToSpace(string $str, bool $trimSpaces = true) : string {  if ($trimSpaces === true) {   $str = trim($str);  }   $str = str_replace('-', ' ', $str);   return $str; }  function toCamel(string $str, string $delim='_') {  $arr = str_split($str);  $openDash = false;  $newStr = '';   foreach ($arr as $chr) {   if ($chr === $delim) {    $openDash = true;    continue;   }   if ($openDash === true) {    $chr = strtoupper($chr);    $openDash = false;   }   $newStr .= $chr;  }   return $newStr; }  function stripIgnoredWords(string $str) : string {  $words = [   "a", "all", "also", "am", "an", "and", "any", "are", "as", "at", "be", "because",   "been", "could", "did", "do", "does", "e.g.", "ever", "from", "had", "hardly",   "has", "have", "having", "he", "hence", "her", "here", "hereby", "herein", "hereof",   "hereon", "hereto", "herewith", "him", "his", "however", "i.e.", "if", "in", "into", "is",   "it", "its", "me", "my", "no", "of", "on", "onto", "our", "really", "said",   "she", "should", "so", "some", "such", "than", "that", "the", "their", "them",   "then", "there", "thereby", "therefore", "therefrom", "therein", "thereof", "thereon", "thereto", "therewith",   "these", "they", "this", "those", "thus", "to", "too", "unto", "us", "very",   "viz", "was", "we", "were", "what", "when", "where", "wherever", "wherein", "whether",   "which", "who", "whom", "whose", "why", "with", "would", "you", "i"  ];   $strChunks = explode(' ', $str);  $newStrChunks = [];   foreach ($strChunks as $strChunk) {   if (in_array(strtolower($strChunk), $words)) {    continue;   }   $newStrChunks[] = $strChunk;  }   $str = implode(' ', $newStrChunks);   return $str; }  function stripPunctuations(string $str) : string {  $punctuations = [   '.', ',', '!',   '/', ':', ';',   '\'', '"', '[',   '{', '}', ']',   '`', '~', '$',   '^', '&', '*',   '=', '(', ')',   '?', '\\'  ];   foreach ($punctuations as $punctuation) {   $str = str_replace($punctuation, '', $str);  }   return $str; }  require_once base_path('/app/Blasta/Classes/Tag.php');  function updateTags(?string $keywordString = null) {  if ($keywordString === null) {   return;  }    $tags = Tag::getInstance();  $keywords = $tags->parse($keywordString);  $tags->add(...$keywords); } /**  * Loads the active themes index  * which is the entry point for the theme's functionalities  */ function loadActiveThemeIndex() {  require_once base_path('/resources/views/front/index.php'); }  /**  * Returns the names of all installed themes  */ function getInstalledThemes() {  return getDirectories(theme_path()); }  /**  * Check if theme exists  */ function themeExists(string $themeName): bool {  $theme = theme_path("/$themeName");   if (file_exists($theme)) {   return true;  }   return false; }  /**  * Returns the screenshot path of all installed themes  */ function getThemeScreenshot(string $themeName): ?string {  $defaultScreenshot = theme_path('/screenshot.jpg');  if (!themeExists($themeName)) {   return null;  }   $screenshot = theme_path("/$themeName/screenshot.jpg");   return file_exists($screenshot) ? $screenshot : $defaultScreenshot; }  /**  * Returns the name of the active theme  */ function getActiveTheme() {  $details = json_decode(file_get_contents(front_path('/details.json')));  return $details->name; }  /**  * Fetch available free themes from an online repository  */ function fetchFreeThemes() {  $url = 'http://localhost:5000/api/v0/free';  return fetch($url); }  /**  * Searches based on query, for an available free theme on an online repository  */ function searchFreeThemes(string $query) {  $url = "http://localhost:5000/api/v0/search-free/$query";  return fetch($url); }  /**  * Activates a theme  */ function activateTheme(string $themeName) {   $themeDir = front_path();  $selectedTheme = theme_path("/$themeName");   if (!file_exists("$selectedTheme/details.json")) {   return;  }   $themeDirContents = new DirectoryIterator($themeDir);  foreach ($themeDirContents as $fileinfo) {   if ($fileinfo->isDot()) {    continue;   }   if ($fileinfo->isDir()) {    deleteDir($themeDir.'/'.$fileinfo->getFileName(), true);   }   if ($fileinfo->isFile()) {    unlink($themeDir.'/'.$fileinfo->getFileName());   }  }    $it = new RecursiveDirectoryIterator($themeDir, RecursiveDirectoryIterator::SKIP_DOTS);  $files = new RecursiveIteratorIterator($it,      RecursiveIteratorIterator::CHILD_FIRST);  foreach($files as $file) {   if ($file->isDir()){    rmdir($file->getPathname());   } else {    unlink($file->getPathname());   }  }    $selectedThemeDir = new DirectoryIterator($selectedTheme);  foreach ($selectedThemeDir as $fileinfo) {   if ($fileinfo->isDot()) {    continue;   }   if ($fileinfo->isDir()) {    rCopy($selectedTheme.'/'.$fileinfo->getFileName(), $themeDir.'/'.$fileinfo->getFileName());   }   if ($fileinfo->isFile()) {    copy($selectedTheme.'/'.$fileinfo->getFileName(), $themeDir.'/'.$fileinfo->getFileName());   }  }   exportAssets(); }  function titleToLink(string $str): string {  $str = stripPunctuations($str);  $str = stripIgnoredWords($str);  $str = spaceToDash($str);  $str = strtolower($str);   return $str; }  function linkToTitle(string $link): string {  $str = explode('/', $link);  $str = $str[count($str) - 1];  $str = ucfirst($str);  $str = str_replace('-', ' ', $str);  return $str; }  require_once base_path('/app/Blasta/Classes/WidgetArea.php'); require_once base_path('/app/Blasta/Classes/Widget.php');  /**  * Registers a widget area on active theme  */ function registerWidgetArea(string $widgetAreaName) {  $widgetArea = WidgetArea::getInstance();  $widgetArea->register($widgetAreaName); }  /**  * Get all widgets  */ function getWidgets() {  $widget = Widget::getInstance();  return $widget->all(); }  /**  * Returns all active widgets  */ function getActiveWidgets(bool $assoc = false) {  $widget = Widget::getInstance();  return $widget->getActive($assoc); }  /**  * Get widget by name  */ function getWidget(string $name) {  $widget = Widget::getInstance();  return $widget->getWidget($name); }  /**  * Get all widget areas  */ function getWidgetAreas() {  $widgetAreas = WidgetArea::getInstance();  return $widgetAreas->all(); }  /**  * Create a new widget  */ function registerWidget(string $name, string $body, ?array $options = null) {  $widget = Widget::getInstance();  $widget->register($name, $body, $options); }  /**  * Adds a widget to a widget area  */ function addToActiveWidgets(string $widgetArea, string $name, string $body, ?array $options = null) {  $jsonPath = base_path('/app/Blasta/active_widgets.json');  $activeWidgets = json_decode(file_get_contents($jsonPath), true);   if ($options !== null) {   $newOptions = [];   foreach ($options as $option => $value) {    $newOptions[] = [unsnakeCase(' ', $option) => $value];   }   $options = $newOptions;  }   $widget = [   'name'   => $name,   'body'   => $body,   'options'   => $options  ];   $activeWidgets[$widgetArea][] = $widget;   file_put_contents($jsonPath, json_encode($activeWidgets)); }  function setActiveWidgets(string $widgetArea, array $widgets) {  $jsonPath = base_path('/app/Blasta/active_widgets.json');  $activeWidgets = json_decode(file_get_contents($jsonPath), true);   unset($activeWidgets[$widgetArea]);   foreach ($widgets as $widget) {   $options = $widget['options'] ?? null;    if ($options !== null) {    $newOptions = [];    foreach ($options as $option => $value) {     $newOptions[unsnakeCase(' ', $option)] = $value;    }    $options = $newOptions;   }    $newWidget = [    'name'   => $widget['name'],    'body'   => $widget['body'],    'options'   => $options   ];     $activeWidgets[$widgetArea][] = $newWidget;  }   file_put_contents($jsonPath, json_encode($activeWidgets)); }  /**  * Loads selected widgets to designated widget areas  */ function loadWidgets(string $widgetArea) {  $jsonPath   = base_path('/app/Blasta/active_widgets.json');  $allWidgets = json_decode(file_get_contents($jsonPath), true);  $widgets = [];   if (empty($allWidgets[$widgetArea])) {   return null;  }   $widgets = json_encode($allWidgets[$widgetArea]);   $_SESSION['widget-area'] = $widgetArea;   return json_decode($widgets); }  /**  * Gets the value of a widget option  */ function getWidgetOption(string $widgetArea, string $widgetName, string $option) {  $jsonPath = base_path('/app/Blasta/active_widgets.json');  $activeWidgets = json_decode(file_get_contents($jsonPath), true);   $i = 0;  foreach ($activeWidgets as $activeWidget) {   foreach ($activeWidget as $index => $value) {    if ($activeWidget[$index]['name'] === $widgetName) {     $i = $index;     break;    }    continue;   }  }   $options = $activeWidgets[$widgetArea][$i]['options'];  $widgetOption = null;   if (!empty($options)) {   foreach ($options as $index) {    foreach ($index as $key => $value) {     if ($key === $option) {      $widgetOption = $value;      break;     }    }   }  }   return $widgetOption; }  /**  * Gets the widget title  */ function getWidgetTitle(string $widgetArea, string $widgetName) {  $title = !empty(getWidgetOption($widgetArea, $widgetName, 'title'))   ? getWidgetOption($widgetArea, $widgetName, 'title')   : $widgetName;   return $title; }  /**  * Gets the widget body  */ function getWidgetBody(object $widget) {  include_once $widget->body; }  /**  * Checks if widget options type is allowed  */ function optionTypeIsAllowed(string $type): bool {  $allowedTypes = [   'checkbox',   'color',   'date',   'datetime',   'datetime-local',   'email',   'month',   'number',   'password',   'range',   'tel',   'text',   'time',   'url',   'week',  ];   if (in_array($type, $allowedTypes)) {   return true;  }   return false; }  /**  * Gets current widget area  */ function getCurrentWidgetArea() {  return $_SESSION['widget-area']; } 