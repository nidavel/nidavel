<?php
 require_once base_path('/app/Blasta/Classes/Body.php');  /**  * Runs just after the opening body tag  */ function startBody() {   return Body::getPrepends(); }  /**  * Runs just before the closing body tag  */ function endBody() {   return Body::getAppends(); }  /**  * Appends to body  */ function appendToBody(string $entity) {   Body::append($entity); }  /**  * Prepends to body  */ function prependToBody(string $entity) {   Body::prepend($entity); }  require_once base_path('app/Blasta/Functions/settings.php');  /**  * Sets the theme color  */ function setThemeColor(string $color) {  settings('w', 'general.theme_color', $color); }  /**  * This function is used to add customizable selectors  * for custom editing  */ function customizeSelectors(string|null $name = null, array|string|null $selectors = null) {  static $allSelectors;   if ($name === null && $selectors == null) {   return $allSelectors;  }   $allowedProperties = [   'color',   'background-color',   'border-color'  ];   $tempSelectors = [];  foreach ($selectors as $selector => $properties) {   if (empty($selector[0])) {    $tempSelectors[$properties] = $allowedProperties;    continue;   } else {    $tempProperties = [];    if (is_array($properties)) {     foreach ($properties as $property) {      if (!in_array($property, $allowedProperties)) {       continue;      }      $tempProperties[] = $property;     }    }    else if (is_string($properties)) {     if (!in_array($properties, $allowedProperties)) {      continue;     }     $tempProperties[] = $properties;    }     $tempSelectors[$selector] = $tempProperties;   }  }   $allSelectors[$name] = $tempSelectors;   return $allSelectors; }  /**  * This function gets all the customizable selectors  */ function getCustomizeableSelectors() {  return customizeSelectors(); }  /**  * This function returns the names of all customized styles  */ function getCustomizedStyleNames() {  $customizedStyles = settings('r', 'general.customized_style_names');  $customizedStyles = explode("'", $customizedStyles);  array_shift($customizedStyles);   return $customizedStyles; }  /**  * Adds a style name to the list of customized styles  */ function addCustomizedStyleName(string $name) {  $customizedStyles = settings('r', 'general.customized_style_names');   if (!isStyleCustomized($name)) {   settings('a', 'general.customized_style_names', "'$name");  }   return true; }  /**  * Removes a style name from the list of customized styles  */ function removeCustomizedStyleName(string $name) {  $customizedStyles = settings('r', 'general.customized_style_names');   if (empty($customizedStyles)) {   return;  }   $customizedStyles = str_replace("'$name", '', $customizedStyles);     settings('w', 'general.customized_style_names', $customizedStyles);   return true; }  /**  * This function checks if a given style name   * is added to the customized list  */ function isStyleCustomized(string $name) {  $customizedStyles = settings('r', 'general.customized_style_names');   if (strpos($customizedStyles, $name) > 0) {   return true;;  }   return false; }  /**  * This function checks if a particular selector is active  * in an active customized style  */ function isSelectorCustomized(string $input) {  $value = explode("'", $input);  $name = $value[0];  $selector = $value[1];   if (isStyleCustomized($name) === false) {   return false;  }   $styleFile = base_path("app/CustomizedStyles/$name");    if (!file_exists($styleFile)) {   return false;  }   $style = file_get_contents(base_path("app/CustomizedStyles/$name"));   if (strpos($style, $selector)) {   return true;  }   return false; }  /**  * This function checks if a particular property is active  * in an active selector in an active customized style  */ function isPropertyCustomized(string $input) {  $value = explode("'", $input);  $name = $value[0];  $selector = $value[1];  $property = $value[2];  $falsePositives = [   'color'  ];   if (isStyleCustomized($name) === false) {   return false;  }   $styleFile = base_path("app/CustomizedStyles/$name");   if (!file_exists($styleFile)) {   return false;  }   $style = file_get_contents($styleFile);   if (strpos($style, $selector)) {   $fp = fopen($styleFile, 'r');   foreach (readFileLine($fp) as $line) {    $idx = strpos($line, $selector);    if ($idx < 1) {     continue;    } else {     $content = '';      if (in_array($property, $falsePositives)) {      $content = substr($line, strpos($line, $property) - 1, strlen($property) + 1);      if ($content[0] === '-') {       $content = substr($line, strpos($line, $property) - 1);       while ($content[0] === '-' && strlen($content) > 0) {        $content = substr($line, strpos($content, $property) - 1);        if ($content[0] !== '-') {         $content = substr($line, strpos($content, $property) - 1, strlen($property) + 1);         break;        }       }      }      $content = ltrim($content, $content[0]);     } else {      $content = substr($line, strpos($line, $property), strlen($property));     }      if ($content === $property) {      fclose($fp);      return true;     }    }   }    fclose($fp);  }   return false; }  /**  * This function gets the value of a given selector in a customized style  */ function getCustomizedSelectorValue(string $input) {  $value = null;  $input = explode("'", $input);  $styleFile = base_path('app/CustomizedStyles/'.$input[0]);  $selector = $input[1];   if (!file_exists($styleFile)) {   return null;  }   $matchx = null;  $content = null;  $fp = fopen($styleFile, 'r');  foreach (readFileLine($fp) as $line) {   $matchx = getSelectorValue($line, $selector);   if (is_null($matchx)) {    continue;   } else {    break;   }  }   fclose($fp);  if (!empty($matchx)) {   $value = str_replace('--color:', '', $matchx);  }   return "$value"; }  /**  * This function returns the specified property and value of a given selector  */ function getSelectorValue(string $line, string $selector) {  $idx = strpos($line, $selector);  $selectorValue = '';   if ($idx < 1) {   return null;  } else {   $values = explode(';', $line);   $selectorValue = substr($values[0], strpos($values[0], '--color'));   return !empty($selectorValue) ? $selectorValue : null;  } }  /**  * This function extracts the red value in an rgba string  */ function getRedFromPropertyValue(string $input) {  $val = stripRGBText($input);  $val = explode(',', $val);  return  $val[0]; }  /**  * This function extracts the green value in an rgba string  */ function getGreenFromPropertyValue(string $input) {  $val = stripRGBText($input);  $val = explode(',', $val);  return  $val[1]; }  /**  * This function extracts the blue value in an rgba string  */ function getBlueFromPropertyValue(string $input) {  $val = stripRGBText($input);  $val = explode(',', $val);  return  $val[2]; }  /**  * This function extracts the alpha value in an rgba string  */ function getAlphaFromPropertyValue(string $input) {  $val = stripRGBText($input);  $val = explode(',', $val);   return  $val[3] ?? 1; }  /**  * This funtion takes a rgb or rgba string and returns the values within  * the parentheses  */ function stripRGBText(string $input) {  $val = trim($input);  $val = ltrim($val, 'rgba(');  $val = ltrim($val, 'rgb(');  $val = rtrim($val, ')');   return $val; }  /**  * This function converts a rgb string to a rgba string  */ function parseRGBA($rgba) {  if (substr(trim($rgba), 0, 4) === 'rgba') {   return $rgba;  }   $rgba = str_replace('rgb', 'rgba', $rgba);  $rgba = str_replace('rgbaa', 'rgba', $rgba);  $rgba = str_replace(')', ', 1)', $rgba);   return $rgba; }  function readFileLine($fp) {  while (!feof($fp)) {   yield fgets($fp);  } }  /**  * Adds a notice to the session  */ function addDashboardNotice(string $id, array $details) {  if (session_status() == PHP_SESSION_NONE) {   session_start();  }  $_SESSION['dashboard-notices'][toSnakeCase(' ', $id)] = $details; }  /**  * Removes a notice from session  */ function removeDashboardNotice(string $id) {  if (session_status() == PHP_SESSION_NONE) {   session_start();  }  $id = toSnakeCase('_', $id);  unset($_SESSION['dashboard-notices'][$id]); }  /**  * Emits an alert to the cookie  */ function emitDashboardAlert(string $title, string $message, string $type) {  $alert = '';  $values = "$title|$message|$type";  setcookie('dashboard-alerts', $values, timestamp() + 86500);  $_COOKIE['dashboard-alerts'] = $values; }  /**  * A download function that gets a file from a url  * and saves it in a given location  */ function download(string $url, string $storageLocation): bool {  $filename = basename($url);       if (file_put_contents("$storageLocation/$filename", file_get_contents($url))) {    return true;  }    return false; }  /**  * Download a plugin from url  */ function downloadPlugin(string $url): bool {  return download($url, plugin_path()); }  /**  * Download a theme from url  */ function downloadTheme(string $url): bool {  return download($url, theme_path()); }   /**  * An extract function to extract zipped file to a given location  */ function extractFile(string $zipped, string $location): bool {  $zip = new ZipArchive;  $filename = basename($zipped);   $res = $zip->open($zipped);   if ($res === true) {   $zip->extractTo("$location");   $zip->close();   return true;  } else {   return false;  } }  /**  * Extract downloaded plugin  */ function extractPlugin(string $zipped): bool {  return extractFile($zipped, plugin_path()); }  /**  * Extract downloaded theme  */ function extractTheme(string $zipped): bool {  return extractFile($zipped, theme_path()); }  /**  * Deletes zipped file  */ function deleteZipped(string $filename): bool {  $finfo = finfo_open(FILEINFO_MIME_TYPE);  $mimeType = finfo_file($finfo, $filename);  finfo_close($finfo);   if ($mimeType === 'application/zip' || $mimeType === 'application/x-rar-compressed') {   return unlink($filename);  }   return false; }  /**  * Deletes zipped plugin  */ function deleteZippedPlugin(string $filename): bool {  return deleteZipped(plugin_path("/$filename")); }  /**  * Deletes zipped theme  */ function deleteZippedTheme(string $filename): bool {  return deleteZipped(theme_path("/$filename")); }  function exportAssets() {  if (file_exists(front_path('/assets.json'))) {   $assets = file_get_contents(front_path('/assets.json'));   $assets = json_decode($assets)->assets;  } else {   return;  }   if (file_exists(public_path('/my_exports/assets'))) {   rrmdir(public_path('/my_exports/assets'));  }   foreach ($assets as $asset) {   $dirs = explode('/', $asset);   $numDirs = count($dirs);   if ($numDirs > 1) {    array_pop($dirs);    $dirs = implode('/', $dirs);     if (!is_dir(public_path("/my_exports/$dirs"))) {     mkdir(public_path("/my_exports/$dirs"), 0777, true);    }   }   copy(front_path("/$asset"), public_path("/my_exports/$asset"));  } }  function exportLink($url = '/', $level = -1) {  $link = homeUrl($url, $level);   if ($_SERVER['SERVER_PORT'] == 8001   && substr($url, 0, 4) != 'http') {   $link .= '.html';  }   return $link; }  function fetch(string $url, string $method = 'GET', $payload = [], array $options = []) {  $ch = curl_init($url);   if (!empty($payload)) {   $payload = json_encode($payload);   curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);  }   if (!empty($options)) {   curl_setopt_array($ch, $options);  }    curl_setopt($ch, CURLOPT_HTTPHEADER, [   'Content-Type: application/json'  ]);  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);   $result = curl_exec($ch);  curl_close($ch);   return $result; }  /**  * Returns a list of directory contents in a directory  */ function getContents(string $dir) {  $contents = [];  $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   if (!$fileinfo->isDot()) {    $contents[] = $fileinfo->getFileName();   }  }   return $contents; }  /**  * Returns a list of directory contents in a directory  * except given  */ function getContentsExcept(string $dir, ?string $except = null) {  $contents = [];  $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   $filename = $fileinfo->getFilename();   if (!$fileinfo->isDot() && $filename !== $except) {    $contents[] = $filename;   }  }   return $contents; }  /**  * Returns a list of directory names in a directory  */ function getDirectories(string $dir) {  $dirs = [];  $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   if (!$fileinfo->isDot() && $fileinfo->isDir()) {    $dirs[] = $fileinfo->getFileName();   }  }   return $dirs; }  /**  * Returns a list of file names in a directory  */ function getFiles(string $dir) {  $files = [];  if (!file_exists($dir)) {   return $files;  }    $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   if (!$fileinfo->isDot() && $fileinfo->isFile()) {    $files[] = $fileinfo->getFileName();   }  }   return $files; }  /**  * Returns a list of file paths in a directory  */ function getFilepaths(string $dir) {  $files = [];  if (!file_exists($dir)) {   return $files;  }    $dir = new DirectoryIterator($dir);  foreach ($dir as $fileinfo) {   if (!$fileinfo->isDot() && $fileinfo->isFile()) {    $files[] = $fileinfo->getPathName();   }  }   return $files; }  /**  * Deletes a directory  */ function deleteDir(string $path, bool $recursive = false) {  if ($recursive === false) {   return rmdir($path);  }   return rrmdir($path); }  /**  * Recursively deletes a directory  */ function rrmdir($path) {  if (!file_exists($path)) {   return;  }    $it = new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS);  $files = new RecursiveIteratorIterator($it,      RecursiveIteratorIterator::CHILD_FIRST);  foreach($files as $file) {   if ($file->isDir()) {    rmdir($file->getPathname());   } else {    unlink($file->getPathname());   }  }  rmdir($path); }  /**  * Recursively copies the contents of a directory  */ function rCopy(  string $sourceDirectory,  string $destinationDirectory,  string $childFolder = '' ): void {  $directory = opendir($sourceDirectory);   if (is_dir($destinationDirectory) === false) {   mkdir($destinationDirectory);  }   if ($childFolder !== '') {   if (is_dir("$destinationDirectory/$childFolder") === false) {    mkdir("$destinationDirectory/$childFolder");   }    while (($file = readdir($directory)) !== false) {    if ($file === '.' || $file === '..') {     continue;    }     if (is_dir("$sourceDirectory/$file") === true) {     rCopy("$sourceDirectory/$file", "$destinationDirectory/$childFolder/$file");    } else {     copy("$sourceDirectory/$file", "$destinationDirectory/$childFolder/$file");    }   }    closedir($directory);    return;  }   while (($file = readdir($directory)) !== false) {   if ($file === '.' || $file === '..') {    continue;   }    if (is_dir("$sourceDirectory/$file") === true) {    rCopy("$sourceDirectory/$file", "$destinationDirectory/$file");   }   else {    copy("$sourceDirectory/$file", "$destinationDirectory/$file");   }  }   closedir($directory); }  require_once base_path('/app/Blasta/Classes/Head.php');  /**  * The meta tags in the post head  */ function postHead($post = null) {  $protocol = settings('r', 'general.protocol');  $domain = settings('r', 'general.domain');   $postHeadString = '';   if ($post !== null) {   $postHeads[] = '<meta name="author" content="'.$post->author.'" />';   $postHeads[] = '<meta name="description" content="'.$post->description.'" />';   $postHeads[] = '<meta name="keywords" content="'.$post->keywords.'" />';   $postHeads[] = '<meta name="theme-color" content="'.settings('r', 'general.theme_color').'" />';   $postHeads[] = '<title>'.$post->title.'</title>';    $postHeads[] = '<meta property="og:title" content="'.$post->title.'" />';   $postHeads[] = '<meta property="og:url" content="'.$protocol.'://'.$domain.'/'.$post->post_type.'s/'.$post->link.'.html" />';   $postHeads[] = '<meta property="og:image" content="'.$protocol.'://'.$domain.'/uploads/'.$post->featured_image.'" />';   $postHeads[] = '<meta property="og:image:width" content="1200" />';   $postHeads[] = '<meta property="og:image:height" content="630" />';   $postHeads[] = '<meta property="og:type" content="article" />';   $postHeads[] = '<meta property="og:description" content="'.$post->description.'" />';    foreach ($postHeads as $postHead) {    $postHeadString .= "$postHead\n";   }  }    return $postHeadString; }  /**  * The customized style to the head   */ function customizedStyles() {  $style = '';  $styleNames = getCustomizedStyleNames();   if (!empty($styleNames)) {   $style .= "<style>\n";  } else {   return null;  }   foreach ($styleNames as $styleName) {   $style .= file_get_contents(base_path("app/CustomizedStyles/$styleName"));  }   $style .= "\n</style>";   appendToHead($style); }  /**  * This function returns all the programmatically added nodes in the head section  */ function getHead() {  return Head::get(); }  /**  * Appends to post head  */ function appendToHead(string $node) {  Head::append($node); }  function homeUrl(string $url = '/', $level = -1) : string {  if ($level == -1) {   $level = count(explode('/', $url)) - 1;  }   $url = trim($url, '.');  $url = trim($url, '/');   if ($_SERVER['SERVER_PORT'] == 8001) {   if ($level == 0) {    $url = './' . $url;   }   while ($level > 0) {    $url = '../' . $url;    $level--;   }  } else {   $url = '/' . $url;  }   return $url; }  function getTimezones() {  return \DateTimeZone::listIdentifiers(); }  function setTimezone(string $timezone = 'UTC') {  if (empty($timezone)) {   $timezone = 'UTC';  }  date_default_timezone_set($timezone); }  function getLocales() {  return [   "af_NA"=>"Afrikaans (Namibia)",   "af_ZA"=>"Afrikaans (South Africa)",   "af"=>"Afrikaans",   "ak_GH"=>"Akan (Ghana)",   "ak"=>"Akan",   "sq_AL"=>"Albanian (Albania)",   "sq"=>"Albanian",   "am_ET"=>"Amharic (Ethiopia)",   "am"=>"Amharic",   "ar_DZ"=>"Arabic (Algeria)",   "ar_BH"=>"Arabic (Bahrain)",   "ar_EG"=>"Arabic (Egypt)",   "ar_IQ"=>"Arabic (Iraq)",   "ar_JO"=>"Arabic (Jordan)",   "ar_KW"=>"Arabic (Kuwait)",   "ar_LB"=>"Arabic (Lebanon)",   "ar_LY"=>"Arabic (Libya)",   "ar_MA"=>"Arabic (Morocco)",   "ar_OM"=>"Arabic (Oman)",   "ar_QA"=>"Arabic (Qatar)",   "ar_SA"=>"Arabic (Saudi Arabia)",   "ar_SD"=>"Arabic (Sudan)",   "ar_SY"=>"Arabic (Syria)",   "ar_TN"=>"Arabic (Tunisia)",   "ar_AE"=>"Arabic (United Arab Emirates)",   "ar_YE"=>"Arabic (Yemen)",   "ar"=>"Arabic",   "hy_AM"=>"Armenian (Armenia)",   "hy"=>"Armenian",   "as_IN"=>"Assamese (India)",   "as"=>"Assamese",   "asa_TZ"=>"Asu (Tanzania)",   "asa"=>"Asu",   "az_Cyrl"=>"Azerbaijani (Cyrillic)",   "az_Cyrl_AZ"=>"Azerbaijani (Cyrillic, Azerbaijan)",   "az_Latn"=>"Azerbaijani (Latin)",   "az_Latn_AZ"=>"Azerbaijani (Latin, Azerbaijan)",   "az"=>"Azerbaijani",   "bm_ML"=>"Bambara (Mali)",   "bm"=>"Bambara",   "eu_ES"=>"Basque (Spain)",   "eu"=>"Basque",   "be_BY"=>"Belarusian (Belarus)",   "be"=>"Belarusian",   "bem_ZM"=>"Bemba (Zambia)",   "bem"=>"Bemba",   "bez_TZ"=>"Bena (Tanzania)",   "bez"=>"Bena",   "bn_BD"=>"Bengali (Bangladesh)",   "bn_IN"=>"Bengali (India)",   "bn"=>"Bengali",   "bs_BA"=>"Bosnian (Bosnia and Herzegovina)",   "bs"=>"Bosnian",   "bg_BG"=>"Bulgarian (Bulgaria)",   "bg"=>"Bulgarian",   "my_MM"=>"Burmese (Myanmar [Burma])",   "my"=>"Burmese",   "yue_Hant_HK"=>"Cantonese (Traditional, Hong Kong SAR China)",   "ca_ES"=>"Catalan (Spain)",   "ca"=>"Catalan",   "tzm_Latn"=>"Central Morocco Tamazight (Latin)",   "tzm_Latn_MA"=>"Central Morocco Tamazight (Latin, Morocco)",   "tzm"=>"Central Morocco Tamazight",   "chr_US"=>"Cherokee (United States)",   "chr"=>"Cherokee",   "cgg_UG"=>"Chiga (Uganda)",   "cgg"=>"Chiga",   "zh_Hans"=>"Chinese (Simplified Han)",   "zh_Hans_CN"=>"Chinese (Simplified Han, China)",   "zh_Hans_HK"=>"Chinese (Simplified Han, Hong Kong SAR China)",   "zh_Hans_MO"=>"Chinese (Simplified Han, Macau SAR China)",   "zh_Hans_SG"=>"Chinese (Simplified Han, Singapore)",   "zh_Hant"=>"Chinese (Traditional Han)",   "zh_Hant_HK"=>"Chinese (Traditional Han, Hong Kong SAR China)",   "zh_Hant_MO"=>"Chinese (Traditional Han, Macau SAR China)",   "zh_Hant_TW"=>"Chinese (Traditional Han, Taiwan)",   "zh"=>"Chinese",   "kw_GB"=>"Cornish (United Kingdom)",   "kw"=>"Cornish",   "hr_HR"=>"Croatian (Croatia)",   "hr"=>"Croatian",   "cs_CZ"=>"Czech (Czech Republic)",   "cs"=>"Czech",   "da_DK"=>"Danish (Denmark)",   "da"=>"Danish",   "nl_BE"=>"Dutch (Belgium)",   "nl_NL"=>"Dutch (Netherlands)",   "nl"=>"Dutch",   "ebu_KE"=>"Embu (Kenya)",   "ebu"=>"Embu",   "en_AS"=>"English (American Samoa)",   "en_AU"=>"English (Australia)",   "en_BE"=>"English (Belgium)",   "en_BZ"=>"English (Belize)",   "en_BW"=>"English (Botswana)",   "en_CA"=>"English (Canada)",   "en_GU"=>"English (Guam)",   "en_HK"=>"English (Hong Kong SAR China)",   "en_IN"=>"English (India)",   "en_IE"=>"English (Ireland)",   "en_IL"=>"English (Israel)",   "en_JM"=>"English (Jamaica)",   "en_MT"=>"English (Malta)",   "en_MH"=>"English (Marshall Islands)",   "en_MU"=>"English (Mauritius)",   "en_NA"=>"English (Namibia)",   "en_NZ"=>"English (New Zealand)",   "en_MP"=>"English (Northern Mariana Islands)",   "en_PK"=>"English (Pakistan)",   "en_PH"=>"English (Philippines)",   "en_SG"=>"English (Singapore)",   "en_ZA"=>"English (South Africa)",   "en_TT"=>"English (Trinidad and Tobago)",   "en_UM"=>"English (U.S. Minor Outlying Islands)",   "en_VI"=>"English (U.S. Virgin Islands)",   "en_GB"=>"English (United Kingdom)",   "en_US"=>"English (United States)",   "en_ZW"=>"English (Zimbabwe)",   "en"=>"English",   "eo"=>"Esperanto",   "et_EE"=>"Estonian (Estonia)",   "et"=>"Estonian",   "ee_GH"=>"Ewe (Ghana)",   "ee_TG"=>"Ewe (Togo)",   "ee"=>"Ewe",   "fo_FO"=>"Faroese (Faroe Islands)",   "fo"=>"Faroese",   "fil_PH"=>"Filipino (Philippines)",   "fil"=>"Filipino",   "fi_FI"=>"Finnish (Finland)",   "fi"=>"Finnish",   "fr_BE"=>"French (Belgium)",   "fr_BJ"=>"French (Benin)",   "fr_BF"=>"French (Burkina Faso)",   "fr_BI"=>"French (Burundi)",   "fr_CM"=>"French (Cameroon)",   "fr_CA"=>"French (Canada)",   "fr_CF"=>"French (Central African Republic)",   "fr_TD"=>"French (Chad)",   "fr_KM"=>"French (Comoros)",   "fr_CG"=>"French (Congo - Brazzaville)",   "fr_CD"=>"French (Congo - Kinshasa)",   "fr_CI"=>"French (Côte d’Ivoire)",   "fr_DJ"=>"French (Djibouti)",   "fr_GQ"=>"French (Equatorial Guinea)",   "fr_FR"=>"French (France)",   "fr_GA"=>"French (Gabon)",   "fr_GP"=>"French (Guadeloupe)",   "fr_GN"=>"French (Guinea)",   "fr_LU"=>"French (Luxembourg)",   "fr_MG"=>"French (Madagascar)",   "fr_ML"=>"French (Mali)",   "fr_MQ"=>"French (Martinique)",   "fr_MC"=>"French (Monaco)",   "fr_NE"=>"French (Niger)",   "fr_RW"=>"French (Rwanda)",   "fr_RE"=>"French (Réunion)",   "fr_BL"=>"French (Saint Barthélemy)",   "fr_MF"=>"French (Saint Martin)",   "fr_SN"=>"French (Senegal)",   "fr_CH"=>"French (Switzerland)",   "fr_TG"=>"French (Togo)",   "fr"=>"French",   "ff_SN"=>"Fulah (Senegal)",   "ff"=>"Fulah",   "gl_ES"=>"Galician (Spain)",   "gl"=>"Galician",   "lg_UG"=>"Ganda (Uganda)",   "lg"=>"Ganda",   "ka_GE"=>"Georgian (Georgia)",   "ka"=>"Georgian",   "de_AT"=>"German (Austria)",   "de_BE"=>"German (Belgium)",   "de_DE"=>"German (Germany)",   "de_LI"=>"German (Liechtenstein)",   "de_LU"=>"German (Luxembourg)",   "de_CH"=>"German (Switzerland)",   "de"=>"German",   "el_CY"=>"Greek (Cyprus)",   "el_GR"=>"Greek (Greece)",   "el"=>"Greek",   "gu_IN"=>"Gujarati (India)",   "gu"=>"Gujarati",   "guz_KE"=>"Gusii (Kenya)",   "guz"=>"Gusii",   "ha_Latn"=>"Hausa (Latin)",   "ha_Latn_GH"=>"Hausa (Latin, Ghana)",   "ha_Latn_NE"=>"Hausa (Latin, Niger)",   "ha_Latn_NG"=>"Hausa (Latin, Nigeria)",   "ha"=>"Hausa",   "haw_US"=>"Hawaiian (United States)",   "haw"=>"Hawaiian",   "he_IL"=>"Hebrew (Israel)",   "he"=>"Hebrew",   "hi_IN"=>"Hindi (India)",   "hi"=>"Hindi",   "hu_HU"=>"Hungarian (Hungary)",   "hu"=>"Hungarian",   "is_IS"=>"Icelandic (Iceland)",   "is"=>"Icelandic",   "ig_NG"=>"Igbo (Nigeria)",   "ig"=>"Igbo",   "id_ID"=>"Indonesian (Indonesia)",   "id"=>"Indonesian",   "ga_IE"=>"Irish (Ireland)",   "ga"=>"Irish",   "it_IT"=>"Italian (Italy)",   "it_CH"=>"Italian (Switzerland)",   "it"=>"Italian",   "ja_JP"=>"Japanese (Japan)",   "ja"=>"Japanese",   "kea_CV"=>"Kabuverdianu (Cape Verde)",   "kea"=>"Kabuverdianu",   "kab_DZ"=>"Kabyle (Algeria)",   "kab"=>"Kabyle",   "kl_GL"=>"Kalaallisut (Greenland)",   "kl"=>"Kalaallisut",   "kln_KE"=>"Kalenjin (Kenya)",   "kln"=>"Kalenjin",   "kam_KE"=>"Kamba (Kenya)",   "kam"=>"Kamba",   "kn_IN"=>"Kannada (India)",   "kn"=>"Kannada",   "kk_Cyrl"=>"Kazakh (Cyrillic)",   "kk_Cyrl_KZ"=>"Kazakh (Cyrillic, Kazakhstan)",   "kk"=>"Kazakh",   "km_KH"=>"Khmer (Cambodia)",   "km"=>"Khmer",   "ki_KE"=>"Kikuyu (Kenya)",   "ki"=>"Kikuyu",   "rw_RW"=>"Kinyarwanda (Rwanda)",   "rw"=>"Kinyarwanda",   "kok_IN"=>"Konkani (India)",   "kok"=>"Konkani",   "ko_KR"=>"Korean (South Korea)",   "ko"=>"Korean",   "khq_ML"=>"Koyra Chiini (Mali)",   "khq"=>"Koyra Chiini",   "ses_ML"=>"Koyraboro Senni (Mali)",   "ses"=>"Koyraboro Senni",   "lag_TZ"=>"Langi (Tanzania)",   "lag"=>"Langi",   "lv_LV"=>"Latvian (Latvia)",   "lv"=>"Latvian",   "lt_LT"=>"Lithuanian (Lithuania)",   "lt"=>"Lithuanian",   "luo_KE"=>"Luo (Kenya)",   "luo"=>"Luo",   "luy_KE"=>"Luyia (Kenya)",   "luy"=>"Luyia",   "mk_MK"=>"Macedonian (Macedonia)",   "mk"=>"Macedonian",   "jmc_TZ"=>"Machame (Tanzania)",   "jmc"=>"Machame",   "kde_TZ"=>"Makonde (Tanzania)",   "kde"=>"Makonde",   "mg_MG"=>"Malagasy (Madagascar)",   "mg"=>"Malagasy",   "ms_BN"=>"Malay (Brunei)",   "ms_MY"=>"Malay (Malaysia)",   "ms"=>"Malay",   "ml_IN"=>"Malayalam (India)",   "ml"=>"Malayalam",   "mt_MT"=>"Maltese (Malta)",   "mt"=>"Maltese",   "gv_GB"=>"Manx (United Kingdom)",   "gv"=>"Manx",   "mr_IN"=>"Marathi (India)",   "mr"=>"Marathi",   "mas_KE"=>"Masai (Kenya)",   "mas_TZ"=>"Masai (Tanzania)",   "mas"=>"Masai",   "mer_KE"=>"Meru (Kenya)",   "mer"=>"Meru",   "mfe_MU"=>"Morisyen (Mauritius)",   "mfe"=>"Morisyen",   "naq_NA"=>"Nama (Namibia)",   "naq"=>"Nama",   "ne_IN"=>"Nepali (India)",   "ne_NP"=>"Nepali (Nepal)",   "ne"=>"Nepali",   "nd_ZW"=>"North Ndebele (Zimbabwe)",   "nd"=>"North Ndebele",   "nb_NO"=>"Norwegian Bokmål (Norway)",   "nb"=>"Norwegian Bokmål",   "nn_NO"=>"Norwegian Nynorsk (Norway)",   "nn"=>"Norwegian Nynorsk",   "nyn_UG"=>"Nyankole (Uganda)",   "nyn"=>"Nyankole",   "or_IN"=>"Oriya (India)",   "or"=>"Oriya",   "om_ET"=>"Oromo (Ethiopia)",   "om_KE"=>"Oromo (Kenya)",   "om"=>"Oromo",   "ps_AF"=>"Pashto (Afghanistan)",   "ps"=>"Pashto",   "fa_AF"=>"Persian (Afghanistan)",   "fa_IR"=>"Persian (Iran)",   "fa"=>"Persian",   "pl_PL"=>"Polish (Poland)",   "pl"=>"Polish",   "pt_BR"=>"Portuguese (Brazil)",   "pt_GW"=>"Portuguese (Guinea-Bissau)",   "pt_MZ"=>"Portuguese (Mozambique)",   "pt_PT"=>"Portuguese (Portugal)",   "pt"=>"Portuguese",   "pa_Arab"=>"Punjabi (Arabic)",   "pa_Arab_PK"=>"Punjabi (Arabic, Pakistan)",   "pa_Guru"=>"Punjabi (Gurmukhi)",   "pa_Guru_IN"=>"Punjabi (Gurmukhi, India)",   "pa"=>"Punjabi",   "ro_MD"=>"Romanian (Moldova)",   "ro_RO"=>"Romanian (Romania)",   "ro"=>"Romanian",   "rm_CH"=>"Romansh (Switzerland)",   "rm"=>"Romansh",   "rof_TZ"=>"Rombo (Tanzania)",   "rof"=>"Rombo",   "ru_MD"=>"Russian (Moldova)",   "ru_RU"=>"Russian (Russia)",   "ru_UA"=>"Russian (Ukraine)",   "ru"=>"Russian",   "rwk_TZ"=>"Rwa (Tanzania)",   "rwk"=>"Rwa",   "saq_KE"=>"Samburu (Kenya)",   "saq"=>"Samburu",   "sg_CF"=>"Sango (Central African Republic)",   "sg"=>"Sango",   "seh_MZ"=>"Sena (Mozambique)",   "seh"=>"Sena",   "sr_Cyrl"=>"Serbian (Cyrillic)",   "sr_Cyrl_BA"=>"Serbian (Cyrillic, Bosnia and Herzegovina)",   "sr_Cyrl_ME"=>"Serbian (Cyrillic, Montenegro)",   "sr_Cyrl_RS"=>"Serbian (Cyrillic, Serbia)",   "sr_Latn"=>"Serbian (Latin)",   "sr_Latn_BA"=>"Serbian (Latin, Bosnia and Herzegovina)",   "sr_Latn_ME"=>"Serbian (Latin, Montenegro)",   "sr_Latn_RS"=>"Serbian (Latin, Serbia)",   "sr"=>"Serbian",   "sn_ZW"=>"Shona (Zimbabwe)",   "sn"=>"Shona",   "ii_CN"=>"Sichuan Yi (China)",   "ii"=>"Sichuan Yi",   "si_LK"=>"Sinhala (Sri Lanka)",   "si"=>"Sinhala",   "sk_SK"=>"Slovak (Slovakia)",   "sk"=>"Slovak",   "sl_SI"=>"Slovenian (Slovenia)",   "sl"=>"Slovenian",   "xog_UG"=>"Soga (Uganda)",   "xog"=>"Soga",   "so_DJ"=>"Somali (Djibouti)",   "so_ET"=>"Somali (Ethiopia)",   "so_KE"=>"Somali (Kenya)",   "so_SO"=>"Somali (Somalia)",   "so"=>"Somali",   "es_AR"=>"Spanish (Argentina)",   "es_BO"=>"Spanish (Bolivia)",   "es_CL"=>"Spanish (Chile)",   "es_CO"=>"Spanish (Colombia)",   "es_CR"=>"Spanish (Costa Rica)",   "es_DO"=>"Spanish (Dominican Republic)",   "es_EC"=>"Spanish (Ecuador)",   "es_SV"=>"Spanish (El Salvador)",   "es_GQ"=>"Spanish (Equatorial Guinea)",   "es_GT"=>"Spanish (Guatemala)",   "es_HN"=>"Spanish (Honduras)",   "es_419"=>"Spanish (Latin America)",   "es_MX"=>"Spanish (Mexico)",   "es_NI"=>"Spanish (Nicaragua)",   "es_PA"=>"Spanish (Panama)",   "es_PY"=>"Spanish (Paraguay)",   "es_PE"=>"Spanish (Peru)",   "es_PR"=>"Spanish (Puerto Rico)",   "es_ES"=>"Spanish (Spain)",   "es_US"=>"Spanish (United States)",   "es_UY"=>"Spanish (Uruguay)",   "es_VE"=>"Spanish (Venezuela)",   "es"=>"Spanish",   "sw_KE"=>"Swahili (Kenya)",   "sw_TZ"=>"Swahili (Tanzania)",   "sw"=>"Swahili",   "sv_FI"=>"Swedish (Finland)",   "sv_SE"=>"Swedish (Sweden)",   "sv"=>"Swedish",   "gsw_CH"=>"Swiss German (Switzerland)",   "gsw"=>"Swiss German",   "shi_Latn"=>"Tachelhit (Latin)",   "shi_Latn_MA"=>"Tachelhit (Latin, Morocco)",   "shi_Tfng"=>"Tachelhit (Tifinagh)",   "shi_Tfng_MA"=>"Tachelhit (Tifinagh, Morocco)",   "shi"=>"Tachelhit",   "dav_KE"=>"Taita (Kenya)",   "dav"=>"Taita",   "ta_IN"=>"Tamil (India)",   "ta_LK"=>"Tamil (Sri Lanka)",   "ta"=>"Tamil",   "te_IN"=>"Telugu (India)",   "te"=>"Telugu",   "teo_KE"=>"Teso (Kenya)",   "teo_UG"=>"Teso (Uganda)",   "teo"=>"Teso",   "th_TH"=>"Thai (Thailand)",   "th"=>"Thai",   "bo_CN"=>"Tibetan (China)",   "bo_IN"=>"Tibetan (India)",   "bo"=>"Tibetan",   "ti_ER"=>"Tigrinya (Eritrea)",   "ti_ET"=>"Tigrinya (Ethiopia)",   "ti"=>"Tigrinya",   "to_TO"=>"Tonga (Tonga)",   "to"=>"Tonga",   "tr_TR"=>"Turkish (Turkey)",   "tr"=>"Turkish",   "uk_UA"=>"Ukrainian (Ukraine)",   "uk"=>"Ukrainian",   "ur_IN"=>"Urdu (India)",   "ur_PK"=>"Urdu (Pakistan)",   "ur"=>"Urdu",   "uz_Arab"=>"Uzbek (Arabic)",   "uz_Arab_AF"=>"Uzbek (Arabic, Afghanistan)",   "uz_Cyrl"=>"Uzbek (Cyrillic)",   "uz_Cyrl_UZ"=>"Uzbek (Cyrillic, Uzbekistan)",   "uz_Latn"=>"Uzbek (Latin)",   "uz_Latn_UZ"=>"Uzbek (Latin, Uzbekistan)",   "uz"=>"Uzbek",   "vi_VN"=>"Vietnamese (Vietnam)",   "vi"=>"Vietnamese",   "vun_TZ"=>"Vunjo (Tanzania)",   "vun"=>"Vunjo",   "cy_GB"=>"Welsh (United Kingdom)",   "cy"=>"Welsh",   "yo_NG"=>"Yoruba (Nigeria)",   "yo"=>"Yoruba",   "zu_ZA"=>"Zulu (South Africa)",   "zu"=>"Zulu"  ]; }  require_once base_path('/app/Blasta/Classes/Settings.php');  function addMenu(string $title, string $url, ?string $target = null) {  $settings = Settings::getInstance();  $settings->add('menu', [   $title => [    'url'    => $url,    'target' => $target   ]  ]); }  function getMenuList() {  $settings = Settings::getInstance();  return $settings->list('menu') ?? []; }  function removeMenu(string $title) {  $settings = Settings::getInstance();  $settings->remove('menu', $title); }  function clearMenu() {  $settings = Settings::getInstance();   $settings->initialize('menu', []);  }  function getMenu() {  $newMenu = [];  $menu = getMenuList();   foreach ($menu as $title => $props) {   if (substr($props['url'], 0, 4) === 'http') {    $newMenu[] = $props['target'] == null     ? '<a aria-label="'.ucfirst($title).'" title="'.ucfirst($title).'" href="'.$props['url'].'">'.ucfirst($title).'</a>'     : '<a aria-label="'.ucfirst($title).'" title="'.ucfirst($title).'" href="'.$props['url'].'" target="'.$props['target'].'">'.ucfirst($title).'</a>';        continue;   }    $newMenu[] = $props['target'] == null    ? '<a aria-label="'.ucfirst($title).'" title="'.ucfirst($title).'" href="'.exportLink($props['url']).'">'.ucfirst($title).'</a>'    : '<a aria-label="'.ucfirst($title).'" title="'.ucfirst($title).'" href="'.exportLink($props['url']).'" target="'.$props['target'].'">'.ucfirst($title).'</a>';  }   return $newMenu; }  /**  * Creates a directory, and creates an index file in it  */ function mkUriDir(string $path): bool {  if (!is_dir($path)) {   if (!mkdir($path)) {    return false;   }  }   if (!file_exists("$path/index.html")) {   $fp = fopen("$path/index.html", 'w');   if (!fclose($fp)) {    return false;   }  }   return true; }  /**  * Returns Nidavel version  */ function getVersion() {  $details = file_get_contents(base_path('app/Blasta/details.json'));  $details = json_decode($details);  $version = $details->version;  return $version; }  /**  * Returns list of contributors  */ function getContributors(bool $toString = true) {  $details = file_get_contents(base_path('app/Blasta/details.json'));  $details = json_decode($details);  $contributors = $details->contributors;   if ($toString === true) {   $contributors = \implode(', ', $contributors);  }    return $contributors; }  function dirPath(string $file = __FILE__) : string {  return dirname($file); }  function front_path(string $resource = '', bool $trailingSlash = false) : string {  $resource = '/' . ltrim($resource, '/');  $path = base_path() . '/resources/views/front' . $resource;  $path .= $trailingSlash === true ? '/' : '';  $path = str_replace('\\', '/', $path);  return $path; }  function plugin_path(string $resource = '', bool $trailingSlash = false): string {  $resource = '/' . ltrim($resource, '/');  $path = base_path() . '/app/Plugins' . $resource;  $path .= $trailingSlash === true ? '/' : '';  $path = str_replace('\\', '/', $path);  return $path; }  function theme_path(string $resource = '', bool $trailingSlash = false): string {  $resource = '/' . ltrim($resource, '/');  $path = base_path() . '/app/Themes' . $resource;  $path .= $trailingSlash === true ? '/' : '';  $path = str_replace('\\', '/', $path);  return $path; }  /**  * Returns the names of all installed plugins  */ function getPlugins() {  return getDirectories(plugin_path()); }  /**  * Returns the details of an installed plugin  */ function getPluginDetails(string $pluginName, bool $assoc = false) {  $details = file_get_contents(plugin_path("/$pluginName/details.json"));   return json_decode($details, $assoc); }  /**  * Checks if plugin exists  */ function pluginExists(string $pluginName): bool {  $plugin = plugin_path("/$pluginName");   if (file_exists($plugin)) {   return true;  }   return false; }  /**  * Marks a plugin as active  */ function markPluginActive(string $pluginName) {  if (!pluginExists($pluginName)) {   throw new Exception("Plugin $pluginName does not exist.");  }   $plugin = plugin_path("/$pluginName");  $mark = '';   $file = fopen("$plugin/ACTIVE", 'w');  fwrite($file, $mark);  fclose($file); }  /**  * Checks if a plugin is active  */ function isPluginActive(string $pluginName): bool {  if (!pluginExists($pluginName)) {   return false;  }   $plugin = plugin_path("/$pluginName");   if (file_exists("$plugin/ACTIVE")) {   return true;  }   return false; }  /**  * Unmarks a plugin as active  */ function unmarkPluginActive(string $pluginName) {  if (!isPluginActive($pluginName)) {   return;  }   $plugin = plugin_path("/$pluginName");   unlink("$plugin/ACTIVE"); }  /**  * Gets all active plugins  */ function getActivePlugins() {  $plugins = getPlugins();  $activePlugins = [];   foreach ($plugins as $plugin) {   if (isPluginActive($plugin)) {    $activePlugins[] = $plugin;   }  }   return $activePlugins; }  /**  * Gets all inactive plugins  */ function getInactivePlugins() {  $plugins = getPlugins();  $inactivePlugins = [];   foreach ($plugins as $plugin) {   if (!isPluginActive($plugin)) {    $inactivePlugins[] = $plugin;   }  }   return $inactivePlugins; }  /**  * Activates a plugin  */ function activatePlugin(string $pluginName) {  markPluginActive($pluginName);   loadActivePlugins(); }  /**  * Deactivates a plugin  */ function deactivatePlugin(string $pluginName) {  unmarkPluginActive($pluginName);   loadActivePlugins(); }  /**  * Loads all active plugins to memory  */ function loadActivePlugins() {  $activePlugins = getActivePlugins();   if (!empty($activePlugins)) {   foreach ($activePlugins as $activePlugin) {    require_once plugin_path("/$activePlugin/index.php");   }  } }  /**  * Loads all active plugins to memory  */ function deletePlugin(string $pluginName) {  if (isPluginActive($pluginName)) {   return false;  }   return deleteDir(plugin_path("/$pluginName"), true); }  /**  * Fetches available free plugins from repository  */ function fetchPlugins() {  $url  = 'https://localhost:5000/api/v0';  $content = file_get_contents($url); }  /**  * Runs functions on plugin activate event  */ function runOnPluginActivate(string|array|callable $function = null, string $pluginName = null) {  static $functions;   if (!is_null($function)) {   compilePluginEventFunctions($function, $functions, $pluginName);  }   return $functions; }  /**  * Runs functions on Plugin deactivate event  */ function runOnPluginDeactivate(string|array|callable $function = null, string $pluginName = null) {  static $functions;   if (!is_null($function)) {   compilePluginEventFunctions($function, $functions, $pluginName);  }   return $functions; }  /**  * Runs functions on Plugin delete event  */ function runOnPluginDelete(string|array|callable $function = null, string $pluginName = null) {  static $functions;   if (!is_null($function)) {   compilePluginEventFunctions($function, $functions, $pluginName);  }   return $functions; }  /**  * Compiles the functions to run for each plugin event  */ function compilePluginEventFunctions(string|array|callable $function = null, &$functions, string $pluginName) {  if (!is_null($function)) {   if (is_string($function)) {    $functions[$pluginName][] = $function;   }    if (is_array($function)) {    foreach ($function as $func) {     $functions[$pluginName][] = $func;    }   }  } }  /**  * Assigns function for respective plugin event  */ function runFunctionsOnPluginEvent(string $event, string $pluginName) {  $functions;   switch ($event) {   case 'plugin-activate':    $functions = runOnPluginActivate();    break;   case 'plugin-deactivate':    $functions = runOnPluginDeactivate();    break;   case 'plugin-delete':    $functions = runOnPluginDelete();    break;   default:    $functions = runOnPluginActivate();  }    runPluginEventFunctions($functions, $pluginName); }  /**  * Runs the function names given as string  */ function runPluginEventFunctions(array|null $functions = null, string|null $pluginName = null) {  if (!empty($functions[$pluginName])) {   foreach ($functions[$pluginName] as $function) {    if (is_string($function)) {     if (function_exists($function)) {      $function();     } else {      throw new Exception("Function $function does not exist", 1);     }    }   }  } }  /**  * Embeds script to the html  */ function embedScript(string $resource, string $location = 'head', array $attributes = []) {  $script = '<script';  foreach ($attributes as $attribute => $value) {   $script .= ' ' . $attribute . '="'. $value . '"';  }  $script .= ">\n";   $script .= file_get_contents($resource) . "\n";   $script .= '</script>';   switch ($location) {   case 'head':    appendToPostHead($script);    break;   case 'body':    appendToBody($script);    break;   default:    exit('Unknown location for embed script');  } }  /**  * Attaches script from online source to the html  */ function sourceScript(string $resource, string $location = 'body', array $attributes = []) {  $script = '<script src="' . $resource . '"';  foreach ($attributes as $attribute => $value) {   $script .= ' ' . $attribute . '="'. $value . '"';  }  $script .= "></script>\n";   switch ($location) {   case 'head':    appendToPostHead($script);    break;   case 'body':    appendToBody($script);    break;   default:    exit('Unknown location for embed script');  } }  /**  * This function replaces a string shortcode with a functionality  */ function shortcode(string $post) {  $codes = getShortcodes();   if (!isset($codes)) {   return $post;  }   foreach ($codes as $code) {   $script = '<script type="text/javascript">';   $script .= file_get_contents($code['resource']);   $script .= '</script>';   $post = str_replace('['.$code['shortcode'].']', $code['replacement'].$script, $post);  }   return $post; }  /**  * This function registers a shortcode to the application  */ function registerShortcode(  string $shortcode   = null,  string $resource = null,  string $description = null,  string $author   = null,  string $replacement = ''  ) {  static $codes;   if (func_num_args() < 1) {   return $codes;  }   if ($codes != null) {   foreach ($codes as $code) {    if ($code['shortcode'] == $shortcode) {     throw new \Exception("Shortcode $shortcode already exist.");    }   }  }   $codes[] = [   'shortcode'  => $shortcode,   'resource'   => $resource,   'description'   => $description,   'author'  => $author,   'replacement'   => $replacement  ]; }  /**  * This function lists all available shortcodes  */ function getShortcodes() {  return registerShortcode(); }   function toSnakeCase(string $delimiter, string $str): string {  return str_replace($delimiter, '_', $str); }  function unSnakeCase(string $delimiter, string $str): string {  return str_replace('_', $delimiter, $str); }  function spaceToDash(string $str, bool $trimSpaces = true) : string {  if ($trimSpaces === true) {   $str = trim($str);  }   $str = str_replace(' ', '-', $str);   return $str; }  function dashToSpace(string $str, bool $trimSpaces = true) : string {  if ($trimSpaces === true) {   $str = trim($str);  }   $str = str_replace('-', ' ', $str);   return $str; }  function toCamel(string $str, string $delim='_') {  $arr = str_split($str);  $openDash = false;  $newStr = '';   foreach ($arr as $chr) {   if ($chr === $delim) {    $openDash = true;    continue;   }   if ($openDash === true) {    $chr = strtoupper($chr);    $openDash = false;   }   $newStr .= $chr;  }   return $newStr; }  function stripIgnoredWords(string $str) : string {  $words = [   "a", "all", "also", "am", "an", "and", "any", "are", "as", "at", "be", "because",   "been", "could", "did", "do", "does", "e.g.", "ever", "from", "had", "hardly",   "has", "have", "having", "he", "hence", "her", "here", "hereby", "herein", "hereof",   "hereon", "hereto", "herewith", "him", "his", "however", "i.e.", "if", "in", "into", "is",   "it", "its", "me", "my", "no", "of", "on", "onto", "our", "really", "said",   "she", "should", "so", "some", "such", "than", "that", "the", "their", "them",   "then", "there", "thereby", "therefore", "therefrom", "therein", "thereof", "thereon", "thereto", "therewith",   "these", "they", "this", "those", "thus", "to", "too", "unto", "us", "very",   "viz", "was", "we", "were", "what", "when", "where", "wherever", "wherein", "whether",   "which", "who", "whom", "whose", "why", "with", "would", "you", "i"  ];   $strChunks = explode(' ', $str);  $newStrChunks = [];   foreach ($strChunks as $strChunk) {   if (in_array(strtolower($strChunk), $words)) {    continue;   }   $newStrChunks[] = $strChunk;  }   $str = implode(' ', $newStrChunks);   return $str; }  function stripPunctuations(string $str) : string {  $punctuations = [   '.', ',', '!',   '/', ':', ';',   '\'', '"', '[',   '{', '}', ']',   '`', '~', '$',   '^', '&', '*',   '=', '(', ')',   '?', '\\'  ];   foreach ($punctuations as $punctuation) {   $str = str_replace($punctuation, '', $str);  }   return $str; }  require_once base_path('/app/Blasta/Classes/Tag.php');  function updateTags(?string $keywordString = null) {  if ($keywordString === null) {   return;  }    $tags = Tag::getInstance();  $keywords = $tags->parse($keywordString);  $tags->add(...$keywords); }  /**  * Loads the active themes index  * which is the entry point for the theme's functionalities  */ function loadActiveThemeIndex() {  require_once base_path('/resources/views/front/index.php'); }  /**  * Returns the names of all installed themes  */ function getInstalledThemes() {  return getDirectories(theme_path()); }  /**  * Check if theme exists  */ function themeExists(string $themeName): bool {  $theme = theme_path("/$themeName");   if (file_exists($theme)) {   return true;  }   return false; }  /**  * Returns the screenshot path of all installed themes  */ function getThemeScreenshot(string $themeName): ?string {  $defaultScreenshot = theme_path('/screenshot.jpg');  if (!themeExists($themeName)) {   return null;  }   $screenshot = theme_path("/$themeName/screenshot.jpg");   return file_exists($screenshot) ? $screenshot : $defaultScreenshot; }  /**  * Returns the name of the active theme  */ function getActiveTheme() {  $details = json_decode(file_get_contents(front_path('/details.json')));  return $details->name; }  /**  * Fetch available free themes from an online repository  */ function fetchFreeThemes() {  $url = 'http://localhost:5000/api/v0/free';  return fetch($url); }  /**  * Searches based on query, for an available free theme on an online repository  */ function searchFreeThemes(string $query) {  $url = "http://localhost:5000/api/v0/search-free/$query";  return fetch($url); }  /**  * Activates a theme  */ function activateTheme(string $themeName) {   $themeDir = front_path();  $selectedTheme = theme_path("/$themeName");   if (!file_exists("$selectedTheme/details.json")) {   return;  }   $themeDirContents = new DirectoryIterator($themeDir);  foreach ($themeDirContents as $fileinfo) {   if ($fileinfo->isDot()) {    continue;   }   if ($fileinfo->isDir()) {    deleteDir($fileinfo->getPathname(), true);   }   if ($fileinfo->isFile()) {    unlink($fileinfo->getPathname());   }  }    $it = new RecursiveDirectoryIterator($themeDir, RecursiveDirectoryIterator::SKIP_DOTS);  $files = new RecursiveIteratorIterator($it,      RecursiveIteratorIterator::CHILD_FIRST);  foreach($files as $file) {   if ($file->isDir()){    rmdir($file->getPathname());   } else {    unlink($file->getPathname());   }  }    $selectedThemeDir = new DirectoryIterator($selectedTheme);  foreach ($selectedThemeDir as $fileinfo) {   if ($fileinfo->isDot()) {    continue;   }   if ($fileinfo->isDir()) {    rCopy($selectedTheme.'/'.$fileinfo->getFileName(), $themeDir.'/'.$fileinfo->getFileName());   }   if ($fileinfo->isFile()) {    copy($selectedTheme.'/'.$fileinfo->getFileName(), $themeDir.'/'.$fileinfo->getFileName());   }  }   exportAssets(); }  /**  * Runs functions on theme activate event  */ function runOnThemeActivate(string|array|callable $function = null) {  static $functions;   compileThemeEventFunctions($function, $functions);   return $functions; }  /**  * Runs functions on theme deactivate event  */ function runOnThemeDeactivate(string|array|callable $function = null) {  static $functions;   compileThemeEventFunctions($function, $functions);   return $functions; }  /**  * Runs functions on theme delete event  */ function runOnThemeDelete(string|array|callable $function = null) {  static $functions;   compileThemeEventFunctions($function, $functions);   return $functions; }  /**  * Compiles the functions to run for each theme event  */ function compileThemeEventFunctions(string|array|callable $function = null, &$functions) {  if (!is_null($function)) {   if (is_string($function)) {    $functions[] = $function;   }    if (is_array($function)) {    foreach ($function as $func) {     $functions[] = $func;    }   }  } }  /**  * Assigns function for respective theme event  */ function runFunctionsOnThemeEvent(string $event) {  $functions;   switch ($event) {   case 'theme-activate':    $functions = runOnThemeActivate();    break;   case 'theme-deactivate':    $functions = runOnThemeDeactivate();    break;   case 'theme-delete':    $functions = runOnThemeDelete();    break;   default:    $functions = runOnThemeActivate();  }    runThemeEventFunctions($functions); }  /**  * Runs the function names given as string  */ function runThemeEventFunctions(array $functions) {  if (!empty($functions)) {   foreach ($functions as $function) {    if (is_string($function)) {     if (function_exists($function)) {      $function();     } else {      throw new Exception("Function $function does not exist", 1);     }    }   }  } }  function titleToLink(string $str): string {  $str = stripPunctuations($str);  $str = stripIgnoredWords($str);  $str = spaceToDash($str);  $str = strtolower($str);   return $str; }  function linkToTitle(string $link): string {  $str = explode('/', $link);  $str = $str[count($str) - 1];  $str = ucfirst($str);  $str = str_replace('-', ' ', $str);  return $str; }  require_once base_path('/app/Blasta/Classes/WidgetArea.php'); require_once base_path('/app/Blasta/Classes/Widget.php');  /**  * Registers a widget area on active theme  */ function registerWidgetArea(string $widgetAreaName) {  $widgetArea = WidgetArea::getInstance();  $widgetArea->register($widgetAreaName); }  /**  * Get all widgets  */ function getWidgets() {  $widget = Widget::getInstance();  return $widget->all(); }  /**  * Returns all active widgets  */ function getActiveWidgets(bool $assoc = false) {  $widget = Widget::getInstance();  return $widget->getActive($assoc); }  /**  * Get widget by name  */ function getWidget(string $name) {  $widget = Widget::getInstance();  return $widget->getWidget($name); }  /**  * Get all widget areas  */ function getWidgetAreas() {  $widgetAreas = WidgetArea::getInstance();  return $widgetAreas->all(); }  /**  * Create a new widget  */ function registerWidget(string $name, string $body, ?array $options = null) {  $widget = Widget::getInstance();  $widget->register($name, $body, $options); }  /**  * Adds a widget to a widget area  */ function addToActiveWidgets(string $widgetArea, string $name, string $body, ?array $options = null) {  $jsonPath = base_path('/app/Blasta/active_widgets.json');  $activeWidgets = json_decode(file_get_contents($jsonPath), true);   if ($options !== null) {   $newOptions = [];   foreach ($options as $option => $value) {    $newOptions[] = [unsnakeCase(' ', $option) => $value];   }   $options = $newOptions;  }   $widget = [   'name'   => $name,   'body'   => $body,   'options'   => $options  ];   $activeWidgets[$widgetArea][] = $widget;   file_put_contents($jsonPath, json_encode($activeWidgets)); }  function setActiveWidgets(string $widgetArea, array $widgets) {  $jsonPath = base_path('/app/Blasta/active_widgets.json');  $activeWidgets = json_decode(file_get_contents($jsonPath), true);   unset($activeWidgets[$widgetArea]);   foreach ($widgets as $widget) {   $options = $widget['options'] ?? null;    if ($options !== null) {    $newOptions = [];    foreach ($options as $option => $value) {     $newOptions[unsnakeCase(' ', $option)] = $value;    }    $options = $newOptions;   }    $newWidget = [    'name'   => $widget['name'],    'body'   => $widget['body'],    'options'   => $options   ];     $activeWidgets[$widgetArea][] = $newWidget;  }   file_put_contents($jsonPath, json_encode($activeWidgets)); }  /**  * Loads selected widgets to designated widget areas  */ function loadWidgets(string $widgetArea) {  $jsonPath   = base_path('/app/Blasta/active_widgets.json');  $allWidgets = json_decode(file_get_contents($jsonPath), true);  $widgets = [];   if (empty($allWidgets[$widgetArea])) {   return null;  }   $widgets = json_encode($allWidgets[$widgetArea]);   $_SESSION['widget-area'] = $widgetArea;   return json_decode($widgets); }  /**  * Gets the value of a widget option  */ function getWidgetOption(string $widgetArea, string $widgetName, string $option) {  $jsonPath = base_path('/app/Blasta/active_widgets.json');  $activeWidgets = json_decode(file_get_contents($jsonPath), true);   $i = 0;  foreach ($activeWidgets as $activeWidget) {   foreach ($activeWidget as $index => $value) {    if ($activeWidget[$index]['name'] === $widgetName) {     $i = $index;     break;    }    continue;   }  }   $options = $activeWidgets[$widgetArea][$i]['options'];  $widgetOption = null;   if (!empty($options)) {   foreach ($options as $index) {    foreach ($index as $key => $value) {     if ($key === $option) {      $widgetOption = $value;      break;     }    }   }  }   return $widgetOption; }  /**  * Gets the widget title  */ function getWidgetTitle(string $widgetArea, string $widgetName) {  $title = !empty(getWidgetOption($widgetArea, $widgetName, 'title'))   ? getWidgetOption($widgetArea, $widgetName, 'title')   : $widgetName;   return $title; }  /**  * Gets the widget body  */ function getWidgetBody(object $widget) {  include_once $widget->body; }  /**  * Checks if widget options type is allowed  */ function optionTypeIsAllowed(string $type): bool {  $allowedTypes = [   'checkbox',   'color',   'date',   'datetime',   'datetime-local',   'email',   'month',   'number',   'password',   'range',   'tel',   'text',   'time',   'url',   'week',  ];   if (in_array($type, $allowedTypes)) {   return true;  }   return false; }  /**  * Gets current widget area  */ function getCurrentWidgetArea() {  return $_SESSION['widget-area']; } 